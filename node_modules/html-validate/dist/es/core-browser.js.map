{"version":3,"file":"core-browser.js","sources":["../../src/htmlvalidate.browser.ts","../../src/config/resolver/browser/import-function.ts","../../src/config/resolver/browser/esm-resolver.ts","../../src/utils/compatibility-check.browser.ts"],"sourcesContent":["import { type SchemaObject } from \"ajv\";\nimport { type ConfigData, type ResolvedConfig, ConfigLoader } from \"./config\";\nimport { normalizeSource, type Source } from \"./context\";\nimport { type SourceHooks } from \"./context/source\";\nimport { type EventDump, type TokenDump, Engine } from \"./engine\";\nimport { type Message } from \"./message\";\nimport { Parser } from \"./parser\";\nimport { type Report, Reporter } from \"./reporter\";\nimport { type RuleDocumentation } from \"./rule\";\nimport configurationSchema from \"./schema/config.json\";\nimport { StaticConfigLoader } from \"./config/loaders/static\";\nimport { isThenable } from \"./utils\";\nimport { UserError } from \"./error\";\nimport {\n\ttype TransformFS,\n\ttransformFilename,\n\ttransformFilenameSync,\n\ttransformSource,\n\ttransformSourceSync,\n} from \"./transform\";\n\nfunction isSourceHooks(value: any): value is SourceHooks {\n\tif (!value || typeof value === \"string\") {\n\t\treturn false;\n\t}\n\treturn Boolean(value.processAttribute ?? value.processElement);\n}\n\nfunction isConfigData(value: any): value is ConfigData {\n\tif (!value || typeof value === \"string\") {\n\t\treturn false;\n\t}\n\treturn !(value.processAttribute ?? value.processElement);\n}\n\n/**\n * Primary API for using HTML-validate.\n *\n * Provides high-level abstractions for common operations.\n *\n * @public\n */\nexport class HtmlValidate {\n\tprotected configLoader: ConfigLoader;\n\n\t/**\n\t * Create a new validator.\n\t *\n\t * @public\n\t * @param configLoader - Use a custom configuration loader.\n\t * @param config - If set it provides the global default configuration. By\n\t * default `Config.defaultConfig()` is used.\n\t */\n\tpublic constructor(config?: ConfigData);\n\tpublic constructor(configLoader: ConfigLoader);\n\tpublic constructor(arg?: ConfigLoader | ConfigData) {\n\t\tconst [loader, config] = arg instanceof ConfigLoader ? [arg, undefined] : [undefined, arg];\n\t\tthis.configLoader = loader ?? new StaticConfigLoader(config);\n\t}\n\n\t/**\n\t * Parse and validate HTML from string.\n\t *\n\t * @public\n\t * @param str - Text to parse.\n\t * @param filename - If set configuration is loaded for given filename.\n\t * @param hooks - Optional hooks (see [[Source]]) for definition.\n\t * @returns Report output.\n\t */\n\t/* eslint-disable @typescript-eslint/unified-signatures -- for easier readability */\n\tpublic validateString(str: string): Promise<Report>;\n\tpublic validateString(str: string, filename: string): Promise<Report>;\n\tpublic validateString(str: string, hooks: SourceHooks): Promise<Report>;\n\tpublic validateString(str: string, options: ConfigData): Promise<Report>;\n\tpublic validateString(str: string, filename: string, hooks: SourceHooks): Promise<Report>;\n\tpublic validateString(str: string, filename: string, options: ConfigData): Promise<Report>;\n\tpublic validateString(\n\t\tstr: string,\n\t\tfilename: string,\n\t\toptions: ConfigData,\n\t\thooks: SourceHooks,\n\t): Promise<Report>;\n\t/* eslint-enable @typescript-eslint/unified-signatures */\n\tpublic validateString(\n\t\tstr: string,\n\t\targ1?: string | SourceHooks | ConfigData,\n\t\targ2?: SourceHooks | ConfigData,\n\t\targ3?: SourceHooks,\n\t): Promise<Report> {\n\t\tconst filename = typeof arg1 === \"string\" ? arg1 : \"inline\";\n\t\tconst options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : undefined; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst source = {\n\t\t\tdata: str,\n\t\t\tfilename,\n\t\t\tline: 1,\n\t\t\tcolumn: 1,\n\t\t\toffset: 0,\n\t\t\thooks,\n\t\t};\n\t\treturn this.validateSource(source, options);\n\t}\n\n\t/**\n\t * Parse and validate HTML from string.\n\t *\n\t * @public\n\t * @param str - Text to parse.\n\t * @param filename - If set configuration is loaded for given filename.\n\t * @param hooks - Optional hooks (see [[Source]]) for definition.\n\t * @returns Report output.\n\t */\n\t/* eslint-disable @typescript-eslint/unified-signatures -- for easier readability */\n\tpublic validateStringSync(str: string): Report;\n\tpublic validateStringSync(str: string, filename: string): Report;\n\tpublic validateStringSync(str: string, hooks: SourceHooks): Report;\n\tpublic validateStringSync(str: string, options: ConfigData): Report;\n\tpublic validateStringSync(str: string, filename: string, hooks: SourceHooks): Report;\n\tpublic validateStringSync(str: string, filename: string, options: ConfigData): Report;\n\tpublic validateStringSync(\n\t\tstr: string,\n\t\tfilename: string,\n\t\toptions: ConfigData,\n\t\thooks: SourceHooks,\n\t): Report;\n\t/* eslint-enable @typescript-eslint/unified-signatures */\n\tpublic validateStringSync(\n\t\tstr: string,\n\t\targ1?: string | SourceHooks | ConfigData,\n\t\targ2?: SourceHooks | ConfigData,\n\t\targ3?: SourceHooks,\n\t): Report {\n\t\tconst filename = typeof arg1 === \"string\" ? arg1 : \"inline\";\n\t\tconst options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : undefined; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst source = {\n\t\t\tdata: str,\n\t\t\tfilename,\n\t\t\tline: 1,\n\t\t\tcolumn: 1,\n\t\t\toffset: 0,\n\t\t\thooks,\n\t\t};\n\t\treturn this.validateSourceSync(source, options);\n\t}\n\n\t/**\n\t * Parse and validate HTML from [[Source]].\n\t *\n\t * @public\n\t * @param input - Source to parse.\n\t * @returns Report output.\n\t */\n\tpublic async validateSource(input: Source, configOverride?: ConfigData): Promise<Report> {\n\t\tconst source = normalizeSource(input);\n\t\tconst config = await this.getConfigFor(source.filename, configOverride);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst transformedSource = await transformSource(resolvers, config, source);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.lint(transformedSource);\n\t}\n\n\t/**\n\t * Parse and validate HTML from [[Source]].\n\t *\n\t * @public\n\t * @param input - Source to parse.\n\t * @returns Report output.\n\t */\n\tpublic validateSourceSync(input: Source, configOverride?: ConfigData): Report {\n\t\tconst source = normalizeSource(input);\n\t\tconst config = this.getConfigForSync(source.filename, configOverride);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst transformedSource = transformSourceSync(resolvers, config, source);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.lint(transformedSource);\n\t}\n\n\t/**\n\t * Parse and validate HTML from file.\n\t *\n\t * @public\n\t * @param filename - Filename to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic async validateFile(filename: string, fs: TransformFS): Promise<Report> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn Promise.resolve(engine.lint(source));\n\t}\n\n\t/**\n\t * Parse and validate HTML from file.\n\t *\n\t * @public\n\t * @param filename - Filename to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic validateFileSync(filename: string, fs: TransformFS): Report {\n\t\tconst config = this.getConfigForSync(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = transformFilenameSync(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.lint(source);\n\t}\n\n\t/**\n\t * Parse and validate HTML from multiple files. Result is merged together to a\n\t * single report.\n\t *\n\t * @param filenames - Filenames to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic async validateMultipleFiles(filenames: string[], fs: TransformFS): Promise<Report> {\n\t\treturn Reporter.merge(filenames.map((filename) => this.validateFile(filename, fs)));\n\t}\n\n\t/**\n\t * Parse and validate HTML from multiple files. Result is merged together to a\n\t * single report.\n\t *\n\t * @param filenames - Filenames to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic validateMultipleFilesSync(filenames: string[], fs: TransformFS): Report {\n\t\treturn Reporter.merge(filenames.map((filename) => this.validateFileSync(filename, fs)));\n\t}\n\n\t/**\n\t * Returns true if the given filename can be validated.\n\t *\n\t * A file is considered to be validatable if the extension is `.html` or if a\n\t * transformer matches the filename.\n\t *\n\t * This is mostly useful for tooling to determine whenever to validate the\n\t * file or not. CLI tools will run on all the given files anyway.\n\t */\n\tpublic async canValidate(filename: string): Promise<boolean> {\n\t\t/* .html is always supported */\n\t\tif (filename.toLowerCase().endsWith(\".html\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\t/* test if there is a matching transformer */\n\t\tconst config = await this.getConfigFor(filename);\n\t\treturn config.canTransform(filename);\n\t}\n\n\t/**\n\t * Returns true if the given filename can be validated.\n\t *\n\t * A file is considered to be validatable if the extension is `.html` or if a\n\t * transformer matches the filename.\n\t *\n\t * This is mostly useful for tooling to determine whenever to validate the\n\t * file or not. CLI tools will run on all the given files anyway.\n\t */\n\tpublic canValidateSync(filename: string): boolean {\n\t\t/* .html is always supported */\n\t\tif (filename.toLowerCase().endsWith(\".html\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\t/* test if there is a matching transformer */\n\t\tconst config = this.getConfigForSync(filename);\n\t\treturn config.canTransform(filename);\n\t}\n\n\t/**\n\t * Tokenize filename and output all tokens.\n\t *\n\t * Using CLI this is enabled with `--dump-tokens`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to tokenize.\n\t */\n\tpublic async dumpTokens(filename: string, fs: TransformFS): Promise<TokenDump[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.dumpTokens(source);\n\t}\n\n\t/**\n\t * Parse filename and output all events.\n\t *\n\t * Using CLI this is enabled with `--dump-events`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to dump events from.\n\t */\n\tpublic async dumpEvents(filename: string, fs: TransformFS): Promise<EventDump[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.dumpEvents(source);\n\t}\n\n\t/**\n\t * Parse filename and output DOM tree.\n\t *\n\t * Using CLI this is enabled with `--dump-tree`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to dump DOM tree from.\n\t */\n\tpublic async dumpTree(filename: string, fs: TransformFS): Promise<string[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.dumpTree(source);\n\t}\n\n\t/**\n\t * Transform filename and output source data.\n\t *\n\t * Using CLI this is enabled with `--dump-source`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to dump source from.\n\t */\n\tpublic async dumpSource(filename: string, fs: TransformFS): Promise<string[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst sources = await transformFilename(resolvers, config, filename, fs);\n\t\treturn sources.reduce<string[]>((result: string[], source: Source) => {\n\t\t\tconst line = String(source.line);\n\t\t\tconst column = String(source.column);\n\t\t\tconst offset = String(source.offset);\n\t\t\tresult.push(`Source ${source.filename}@${line}:${column} (offset: ${offset})`);\n\t\t\tif (source.transformedBy) {\n\t\t\t\tresult.push(\"Transformed by:\");\n\t\t\t\t/* eslint-disable-next-line sonarjs/no-misleading-array-reverse -- technical debt */\n\t\t\t\tresult = result.concat(source.transformedBy.reverse().map((name) => ` - ${name}`));\n\t\t\t}\n\t\t\tif (source.hooks && Object.keys(source.hooks).length > 0) {\n\t\t\t\tresult.push(\"Hooks\");\n\t\t\t\tfor (const [key, present] of Object.entries(source.hooks)) {\n\t\t\t\t\tif (present) {\n\t\t\t\t\t\tresult.push(` - ${key}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.push(\"---\");\n\t\t\tresult = result.concat(source.data.split(\"\\n\"));\n\t\t\tresult.push(\"---\");\n\t\t\treturn result;\n\t\t}, []);\n\t}\n\n\t/**\n\t * Get effective configuration schema.\n\t */\n\tpublic getConfigurationSchema(): Promise<SchemaObject> {\n\t\treturn Promise.resolve(configurationSchema);\n\t}\n\n\t/**\n\t * Get effective metadata element schema.\n\t *\n\t * If a filename is given the configured plugins can extend the\n\t * schema. Filename must not be an existing file or a filetype normally\n\t * handled by html-validate but the path will be used when resolving\n\t * configuration. As a rule-of-thumb, set it to the elements json file.\n\t */\n\tpublic async getElementsSchema(filename?: string): Promise<SchemaObject> {\n\t\tconst config = await this.getConfigFor(filename ?? \"inline\");\n\t\tconst metaTable = config.getMetaTable();\n\t\treturn metaTable.getJSONSchema();\n\t}\n\n\t/**\n\t * Get effective metadata element schema.\n\t *\n\t * If a filename is given the configured plugins can extend the\n\t * schema. Filename must not be an existing file or a filetype normally\n\t * handled by html-validate but the path will be used when resolving\n\t * configuration. As a rule-of-thumb, set it to the elements json file.\n\t */\n\tpublic getElementsSchemaSync(filename?: string): SchemaObject {\n\t\tconst config = this.getConfigForSync(filename ?? \"inline\");\n\t\tconst metaTable = config.getMetaTable();\n\t\treturn metaTable.getJSONSchema();\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule. Configuration will be\n\t * resolved for given filename.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = await htmlvalidate.validateFile(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = await htmlvalidate.getContextualDocumentation(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param filename - Filename used to resolve configuration.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentation(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilename?: string,\n\t): Promise<RuleDocumentation | null>;\n\n\t/**\n\t * Get contextual documentation for the given rule using provided\n\t * configuration.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = await htmlvalidate.validateFile(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = await htmlvalidate.getRuleDocumentation(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param config - Configuration to use.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentation(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tconfig: ResolvedConfig | Promise<ResolvedConfig>,\n\t): Promise<RuleDocumentation | null>;\n\n\tpublic async getContextualDocumentation(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilenameOrConfig: ResolvedConfig | Promise<ResolvedConfig> | string = \"inline\",\n\t): Promise<RuleDocumentation | null> {\n\t\tconst config =\n\t\t\ttypeof filenameOrConfig === \"string\"\n\t\t\t\t? await this.getConfigFor(filenameOrConfig)\n\t\t\t\t: await filenameOrConfig;\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.getRuleDocumentation(message);\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule. Configuration will be\n\t * resolved for given filename.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = htmlvalidate.validateFileSync(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = htmlvalidate.getRuleDocumentationSync(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param filename - Filename used to resolve configuration.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentationSync(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilename?: string,\n\t): RuleDocumentation | null;\n\n\t/**\n\t * Get contextual documentation for the given rule using provided\n\t * configuration.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = htmlvalidate.validateFileSync(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = htmlvalidate.getRuleDocumentationSync(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param config - Configuration to use.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentationSync(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tconfig: ResolvedConfig,\n\t): RuleDocumentation | null;\n\n\tpublic getContextualDocumentationSync(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilenameOrConfig: ResolvedConfig | string = \"inline\",\n\t): RuleDocumentation | null {\n\t\tconst config =\n\t\t\ttypeof filenameOrConfig === \"string\"\n\t\t\t\t? this.getConfigForSync(filenameOrConfig)\n\t\t\t\t: filenameOrConfig;\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.getRuleDocumentation(message);\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule.\n\t *\n\t * Typical usage:\n\t *\n\t * ```js\n\t * const report = await htmlvalidate.validateFile(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   const config = await htmlvalidate.getConfigFor(result.filePath);\n\t *   for (const message of result.messages){\n\t *     const documentation = await htmlvalidate.getRuleDocumentation(message.ruleId, config, message.context);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentation]] instead.\n\t * @param ruleId - Rule to get documentation for.\n\t * @param config - If set it provides more accurate description by using the\n\t * correct configuration for the file.\n\t * @param context - If set to `Message.context` some rules can provide\n\t * contextual details and suggestions.\n\t */\n\tpublic async getRuleDocumentation(\n\t\truleId: string,\n\t\tconfig: ResolvedConfig | Promise<ResolvedConfig> | null = null,\n\t\tcontext: unknown | null = null,\n\t): Promise<RuleDocumentation | null> {\n\t\tconst c = config ?? this.getConfigFor(\"inline\");\n\t\tconst engine = new Engine(await c, Parser);\n\t\treturn engine.getRuleDocumentation({ ruleId, context });\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule.\n\t *\n\t * Typical usage:\n\t *\n\t * ```js\n\t * const report = htmlvalidate.validateFileSync(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   const config = htmlvalidate.getConfigForSync(result.filePath);\n\t *   for (const message of result.messages){\n\t *     const documentation = htmlvalidate.getRuleDocumentationSync(message.ruleId, config, message.context);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentationSync]] instead.\n\t * @param ruleId - Rule to get documentation for.\n\t * @param config - If set it provides more accurate description by using the\n\t * correct configuration for the file.\n\t * @param context - If set to `Message.context` some rules can provide\n\t * contextual details and suggestions.\n\t */\n\tpublic getRuleDocumentationSync(\n\t\truleId: string,\n\t\tconfig: ResolvedConfig | null = null,\n\t\tcontext: unknown | null = null,\n\t): RuleDocumentation | null {\n\t\tconst c = config ?? this.getConfigForSync(\"inline\");\n\t\tconst engine = new Engine(c, Parser);\n\t\treturn engine.getRuleDocumentation({ ruleId, context });\n\t}\n\n\t/**\n\t * Create a parser configured for given filename.\n\t *\n\t * @internal\n\t * @param source - Source to use.\n\t */\n\tpublic async getParserFor(source: Source): Promise<Parser> {\n\t\tconst config = await this.getConfigFor(source.filename);\n\t\treturn new Parser(config);\n\t}\n\n\t/**\n\t * Get configuration for given filename.\n\t *\n\t * See [[FileSystemConfigLoader]] for details.\n\t *\n\t * @public\n\t * @param filename - Filename to get configuration for.\n\t * @param configOverride - Configuration to apply last.\n\t */\n\tpublic getConfigFor(filename: string, configOverride?: ConfigData): Promise<ResolvedConfig> {\n\t\tconst config = this.configLoader.getConfigFor(filename, configOverride);\n\t\treturn Promise.resolve(config);\n\t}\n\n\t/**\n\t * Get configuration for given filename.\n\t *\n\t * See [[FileSystemConfigLoader]] for details.\n\t *\n\t * @public\n\t * @param filename - Filename to get configuration for.\n\t * @param configOverride - Configuration to apply last.\n\t */\n\tpublic getConfigForSync(filename: string, configOverride?: ConfigData): ResolvedConfig {\n\t\tconst config = this.configLoader.getConfigFor(filename, configOverride);\n\t\tif (isThenable(config)) {\n\t\t\tthrow new UserError(\"Cannot use asynchronous config loader with synchronous api\");\n\t\t}\n\t\treturn config;\n\t}\n\n\t/**\n\t * Get current configuration loader.\n\t *\n\t * @public\n\t * @since %version%\n\t * @returns Current configuration loader.\n\t */\n\t/* istanbul ignore next -- not testing setters/getters */\n\tpublic getConfigLoader(): ConfigLoader {\n\t\treturn this.configLoader;\n\t}\n\n\t/**\n\t * Set configuration loader.\n\t *\n\t * @public\n\t * @since %version%\n\t * @param loader - New configuration loader to use.\n\t */\n\t/* istanbul ignore next -- not testing setters/getters */\n\tpublic setConfigLoader(loader: ConfigLoader): void {\n\t\tthis.configLoader = loader;\n\t}\n\n\t/**\n\t * Flush configuration cache. Clears full cache unless a filename is given.\n\t *\n\t * See [[FileSystemConfigLoader]] for details.\n\t *\n\t * @public\n\t * @param filename - If set, only flush cache for given filename.\n\t */\n\tpublic flushConfigCache(filename?: string): void {\n\t\tthis.configLoader.flushCache(filename);\n\t}\n}\n","/* istanbul ignore file: this file is only for easier mocking */\n\n/**\n * Wrapper around import() so we can mock it in unittests.\n *\n * @internal\n */\nexport function importFunction(id: string): unknown {\n\treturn import(id);\n}\n","import { UserError } from \"../../../error\";\nimport { type MetaDataTable } from \"../../../meta\";\nimport { type Plugin } from \"../../../plugin\";\nimport { type Transformer } from \"../../../transform\";\nimport { type ConfigData } from \"../../config-data\";\nimport { type Resolver } from \"../resolver\";\nimport { importFunction } from \"./import-function\";\n\nexport async function internalImport<T = unknown>(id: string): Promise<T | null> {\n\tconst { default: defaultImport } = (await importFunction(id)) as { default?: T };\n\tif (!defaultImport) {\n\t\tthrow new UserError(`\"${id}\" does not have a default export`);\n\t}\n\treturn defaultImport;\n}\n\n/**\n * ESM resolver.\n *\n * @public\n * @since 9.0.0\n */\nexport type ESMResolver = Required<Resolver>;\n\n/**\n * Create a new resolver for  using `import(..)`.\n *\n * @public\n * @since 9.0.0\n */\nexport function esmResolver(): ESMResolver {\n\treturn {\n\t\tname: \"esm-resolver\",\n\n\t\tresolveElements(id: string): Promise<MetaDataTable | null> {\n\t\t\treturn internalImport(id);\n\t\t},\n\n\t\tresolveConfig(id: string): Promise<ConfigData | null> {\n\t\t\treturn internalImport(id);\n\t\t},\n\n\t\tresolvePlugin(id: string): Promise<Plugin | null> {\n\t\t\treturn internalImport<Plugin>(id);\n\t\t},\n\n\t\tasync resolveTransformer(id: string): Promise<Transformer | null> {\n\t\t\treturn internalImport(id);\n\t\t},\n\t};\n}\n","import { version } from \"../generated/package\";\nimport { type CompatibilityOptions, compatibilityCheckImpl } from \"./compatibility-check\";\n\nconst defaults: CompatibilityOptions = {\n\tsilent: false,\n\tversion,\n\tlogger(text: string): void {\n\t\t/* eslint-disable-next-line no-console -- expected to log */\n\t\tconsole.error(text);\n\t},\n};\n\n/**\n * Tests if plugin is compatible with html-validate library. Unless the `silent`\n * option is used a warning is displayed on the console.\n *\n * @public\n * @since v5.0.0\n * @param name - Name of plugin\n * @param declared - What library versions the plugin support (e.g. declared peerDependencies)\n * @returns - `true` if version is compatible\n */\nexport function compatibilityCheck(\n\tname: string,\n\tdeclared: string,\n\toptions?: Partial<CompatibilityOptions>,\n): boolean {\n\treturn compatibilityCheckImpl(name, declared, {\n\t\t...defaults,\n\t\t...options,\n\t});\n}\n"],"names":[],"mappings":"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"}