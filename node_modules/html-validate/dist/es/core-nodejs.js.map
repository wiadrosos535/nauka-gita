{"version":3,"file":"core-nodejs.js","sources":["../../src/utils/require-uncached.ts","../../src/htmlvalidate.nodejs.ts","../../src/config/resolver/nodejs/determine-root-dir.ts","../../src/config/resolver/nodejs/expand-relative-path.ts","../../src/config/resolver/nodejs/cjs-resolver.ts","../../src/config/resolver/nodejs/import-function.ts","../../src/config/resolver/nodejs/internal-import.ts","../../src/config/resolver/nodejs/esm-resolver.ts","../../src/config/loaders/file-system.ts","../../src/utils/compatibility-check.nodejs.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-deprecated -- works for now and this will be removed when commonjs support ends */\n\n/**\n * Similar to `require(..)` but removes the cached copy first.\n */\nexport function requireUncached(require: NodeJS.Require, moduleId: string): unknown {\n\tconst filename = require.resolve(moduleId);\n\n\t/* remove references from the parent module to prevent memory leak */\n\tconst m = require.cache[filename];\n\tif (m?.parent) {\n\t\tconst { parent } = m;\n\t\tfor (let i = parent.children.length - 1; i >= 0; i--) {\n\t\t\tif (parent.children[i].id === filename) {\n\t\t\t\tparent.children.splice(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* remove old module from cache */\n\t/* eslint-disable-next-line @typescript-eslint/no-dynamic-delete -- needed to perform its function */\n\tdelete require.cache[filename];\n\n\t/* eslint-disable-next-line import/no-dynamic-require, security/detect-non-literal-require -- as expected but should be moved to upcoming resolver class */\n\treturn require(filename);\n}\n","import fs from \"node:fs\";\nimport { type SchemaObject } from \"ajv\";\nimport { type ConfigData, type ResolvedConfig, ConfigLoader } from \"./config\";\nimport { normalizeSource, type Source } from \"./context\";\nimport { type SourceHooks } from \"./context/source\";\nimport { type EventDump, type TokenDump, Engine } from \"./engine\";\nimport { type Message } from \"./message\";\nimport { Parser } from \"./parser\";\nimport { type Report, Reporter } from \"./reporter\";\nimport { type RuleDocumentation } from \"./rule\";\nimport configurationSchema from \"./schema/config.json\";\nimport { StaticConfigLoader } from \"./config/loaders/static\";\nimport { isThenable } from \"./utils\";\nimport { UserError } from \"./error\";\nimport {\n\ttype TransformFS,\n\ttransformFilename,\n\ttransformFilenameSync,\n\ttransformSource,\n\ttransformSourceSync,\n} from \"./transform\";\n\nconst defaultFS: TransformFS = {\n\treadFileSync: fs.readFileSync,\n};\n\nfunction isSourceHooks(value: any): value is SourceHooks {\n\tif (!value || typeof value === \"string\") {\n\t\treturn false;\n\t}\n\treturn Boolean(value.processAttribute ?? value.processElement);\n}\n\nfunction isConfigData(value: any): value is ConfigData {\n\tif (!value || typeof value === \"string\") {\n\t\treturn false;\n\t}\n\treturn !(value.processAttribute ?? value.processElement);\n}\n\n/**\n * Primary API for using HTML-validate.\n *\n * Provides high-level abstractions for common operations.\n *\n * @public\n */\nexport class HtmlValidate {\n\tprotected configLoader: ConfigLoader;\n\n\t/**\n\t * Create a new validator.\n\t *\n\t * @public\n\t * @param configLoader - Use a custom configuration loader.\n\t * @param config - If set it provides the global default configuration. By\n\t * default `Config.defaultConfig()` is used.\n\t */\n\tpublic constructor(config?: ConfigData);\n\tpublic constructor(configLoader: ConfigLoader);\n\tpublic constructor(arg?: ConfigLoader | ConfigData) {\n\t\tconst [loader, config] = arg instanceof ConfigLoader ? [arg, undefined] : [undefined, arg];\n\t\tthis.configLoader = loader ?? new StaticConfigLoader(config);\n\t}\n\n\t/**\n\t * Parse and validate HTML from string.\n\t *\n\t * @public\n\t * @param str - Text to parse.\n\t * @param filename - If set configuration is loaded for given filename.\n\t * @param hooks - Optional hooks (see [[Source]]) for definition.\n\t * @returns Report output.\n\t */\n\t/* eslint-disable @typescript-eslint/unified-signatures -- for easier readability */\n\tpublic validateString(str: string): Promise<Report>;\n\tpublic validateString(str: string, filename: string): Promise<Report>;\n\tpublic validateString(str: string, hooks: SourceHooks): Promise<Report>;\n\tpublic validateString(str: string, options: ConfigData): Promise<Report>;\n\tpublic validateString(str: string, filename: string, hooks: SourceHooks): Promise<Report>;\n\tpublic validateString(str: string, filename: string, options: ConfigData): Promise<Report>;\n\tpublic validateString(\n\t\tstr: string,\n\t\tfilename: string,\n\t\toptions: ConfigData,\n\t\thooks: SourceHooks,\n\t): Promise<Report>;\n\t/* eslint-enable @typescript-eslint/unified-signatures */\n\tpublic validateString(\n\t\tstr: string,\n\t\targ1?: string | SourceHooks | ConfigData,\n\t\targ2?: SourceHooks | ConfigData,\n\t\targ3?: SourceHooks,\n\t): Promise<Report> {\n\t\tconst filename = typeof arg1 === \"string\" ? arg1 : \"inline\";\n\t\tconst options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : undefined; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst source = {\n\t\t\tdata: str,\n\t\t\tfilename,\n\t\t\tline: 1,\n\t\t\tcolumn: 1,\n\t\t\toffset: 0,\n\t\t\thooks,\n\t\t};\n\t\treturn this.validateSource(source, options);\n\t}\n\n\t/**\n\t * Parse and validate HTML from string.\n\t *\n\t * @public\n\t * @param str - Text to parse.\n\t * @param filename - If set configuration is loaded for given filename.\n\t * @param hooks - Optional hooks (see [[Source]]) for definition.\n\t * @returns Report output.\n\t */\n\t/* eslint-disable @typescript-eslint/unified-signatures -- for easier readability */\n\tpublic validateStringSync(str: string): Report;\n\tpublic validateStringSync(str: string, filename: string): Report;\n\tpublic validateStringSync(str: string, hooks: SourceHooks): Report;\n\tpublic validateStringSync(str: string, options: ConfigData): Report;\n\tpublic validateStringSync(str: string, filename: string, hooks: SourceHooks): Report;\n\tpublic validateStringSync(str: string, filename: string, options: ConfigData): Report;\n\tpublic validateStringSync(\n\t\tstr: string,\n\t\tfilename: string,\n\t\toptions: ConfigData,\n\t\thooks: SourceHooks,\n\t): Report;\n\t/* eslint-enable @typescript-eslint/unified-signatures */\n\tpublic validateStringSync(\n\t\tstr: string,\n\t\targ1?: string | SourceHooks | ConfigData,\n\t\targ2?: SourceHooks | ConfigData,\n\t\targ3?: SourceHooks,\n\t): Report {\n\t\tconst filename = typeof arg1 === \"string\" ? arg1 : \"inline\";\n\t\tconst options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : undefined; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst source = {\n\t\t\tdata: str,\n\t\t\tfilename,\n\t\t\tline: 1,\n\t\t\tcolumn: 1,\n\t\t\toffset: 0,\n\t\t\thooks,\n\t\t};\n\t\treturn this.validateSourceSync(source, options);\n\t}\n\n\t/**\n\t * Parse and validate HTML from [[Source]].\n\t *\n\t * @public\n\t * @param input - Source to parse.\n\t * @returns Report output.\n\t */\n\tpublic async validateSource(input: Source, configOverride?: ConfigData): Promise<Report> {\n\t\tconst source = normalizeSource(input);\n\t\tconst config = await this.getConfigFor(source.filename, configOverride);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst transformedSource = await transformSource(resolvers, config, source);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.lint(transformedSource);\n\t}\n\n\t/**\n\t * Parse and validate HTML from [[Source]].\n\t *\n\t * @public\n\t * @param input - Source to parse.\n\t * @returns Report output.\n\t */\n\tpublic validateSourceSync(input: Source, configOverride?: ConfigData): Report {\n\t\tconst source = normalizeSource(input);\n\t\tconst config = this.getConfigForSync(source.filename, configOverride);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst transformedSource = transformSourceSync(resolvers, config, source);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.lint(transformedSource);\n\t}\n\n\t/**\n\t * Parse and validate HTML from file.\n\t *\n\t * @public\n\t * @param filename - Filename to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic async validateFile(filename: string, fs: TransformFS = defaultFS): Promise<Report> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn Promise.resolve(engine.lint(source));\n\t}\n\n\t/**\n\t * Parse and validate HTML from file.\n\t *\n\t * @public\n\t * @param filename - Filename to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic validateFileSync(filename: string, fs: TransformFS = defaultFS): Report {\n\t\tconst config = this.getConfigForSync(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = transformFilenameSync(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.lint(source);\n\t}\n\n\t/**\n\t * Parse and validate HTML from multiple files. Result is merged together to a\n\t * single report.\n\t *\n\t * @param filenames - Filenames to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic async validateMultipleFiles(\n\t\tfilenames: string[],\n\t\tfs: TransformFS = defaultFS,\n\t): Promise<Report> {\n\t\treturn Reporter.merge(filenames.map((filename) => this.validateFile(filename, fs)));\n\t}\n\n\t/**\n\t * Parse and validate HTML from multiple files. Result is merged together to a\n\t * single report.\n\t *\n\t * @param filenames - Filenames to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic validateMultipleFilesSync(filenames: string[], fs: TransformFS = defaultFS): Report {\n\t\treturn Reporter.merge(filenames.map((filename) => this.validateFileSync(filename, fs)));\n\t}\n\n\t/**\n\t * Returns true if the given filename can be validated.\n\t *\n\t * A file is considered to be validatable if the extension is `.html` or if a\n\t * transformer matches the filename.\n\t *\n\t * This is mostly useful for tooling to determine whenever to validate the\n\t * file or not. CLI tools will run on all the given files anyway.\n\t */\n\tpublic async canValidate(filename: string): Promise<boolean> {\n\t\t/* .html is always supported */\n\t\tif (filename.toLowerCase().endsWith(\".html\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\t/* test if there is a matching transformer */\n\t\tconst config = await this.getConfigFor(filename);\n\t\treturn config.canTransform(filename);\n\t}\n\n\t/**\n\t * Returns true if the given filename can be validated.\n\t *\n\t * A file is considered to be validatable if the extension is `.html` or if a\n\t * transformer matches the filename.\n\t *\n\t * This is mostly useful for tooling to determine whenever to validate the\n\t * file or not. CLI tools will run on all the given files anyway.\n\t */\n\tpublic canValidateSync(filename: string): boolean {\n\t\t/* .html is always supported */\n\t\tif (filename.toLowerCase().endsWith(\".html\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\t/* test if there is a matching transformer */\n\t\tconst config = this.getConfigForSync(filename);\n\t\treturn config.canTransform(filename);\n\t}\n\n\t/**\n\t * Tokenize filename and output all tokens.\n\t *\n\t * Using CLI this is enabled with `--dump-tokens`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to tokenize.\n\t */\n\tpublic async dumpTokens(filename: string, fs: TransformFS = defaultFS): Promise<TokenDump[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.dumpTokens(source);\n\t}\n\n\t/**\n\t * Parse filename and output all events.\n\t *\n\t * Using CLI this is enabled with `--dump-events`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to dump events from.\n\t */\n\tpublic async dumpEvents(filename: string, fs: TransformFS = defaultFS): Promise<EventDump[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.dumpEvents(source);\n\t}\n\n\t/**\n\t * Parse filename and output DOM tree.\n\t *\n\t * Using CLI this is enabled with `--dump-tree`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to dump DOM tree from.\n\t */\n\tpublic async dumpTree(filename: string, fs: TransformFS = defaultFS): Promise<string[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.dumpTree(source);\n\t}\n\n\t/**\n\t * Transform filename and output source data.\n\t *\n\t * Using CLI this is enabled with `--dump-source`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to dump source from.\n\t */\n\tpublic async dumpSource(filename: string, fs: TransformFS = defaultFS): Promise<string[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst sources = await transformFilename(resolvers, config, filename, fs);\n\t\treturn sources.reduce<string[]>((result: string[], source: Source) => {\n\t\t\tconst line = String(source.line);\n\t\t\tconst column = String(source.column);\n\t\t\tconst offset = String(source.offset);\n\t\t\tresult.push(`Source ${source.filename}@${line}:${column} (offset: ${offset})`);\n\t\t\tif (source.transformedBy) {\n\t\t\t\tresult.push(\"Transformed by:\");\n\t\t\t\t/* eslint-disable-next-line sonarjs/no-misleading-array-reverse -- technical debt */\n\t\t\t\tresult = result.concat(source.transformedBy.reverse().map((name) => ` - ${name}`));\n\t\t\t}\n\t\t\tif (source.hooks && Object.keys(source.hooks).length > 0) {\n\t\t\t\tresult.push(\"Hooks\");\n\t\t\t\tfor (const [key, present] of Object.entries(source.hooks)) {\n\t\t\t\t\tif (present) {\n\t\t\t\t\t\tresult.push(` - ${key}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.push(\"---\");\n\t\t\tresult = result.concat(source.data.split(\"\\n\"));\n\t\t\tresult.push(\"---\");\n\t\t\treturn result;\n\t\t}, []);\n\t}\n\n\t/**\n\t * Get effective configuration schema.\n\t */\n\tpublic getConfigurationSchema(): Promise<SchemaObject> {\n\t\treturn Promise.resolve(configurationSchema);\n\t}\n\n\t/**\n\t * Get effective metadata element schema.\n\t *\n\t * If a filename is given the configured plugins can extend the\n\t * schema. Filename must not be an existing file or a filetype normally\n\t * handled by html-validate but the path will be used when resolving\n\t * configuration. As a rule-of-thumb, set it to the elements json file.\n\t */\n\tpublic async getElementsSchema(filename?: string): Promise<SchemaObject> {\n\t\tconst config = await this.getConfigFor(filename ?? \"inline\");\n\t\tconst metaTable = config.getMetaTable();\n\t\treturn metaTable.getJSONSchema();\n\t}\n\n\t/**\n\t * Get effective metadata element schema.\n\t *\n\t * If a filename is given the configured plugins can extend the\n\t * schema. Filename must not be an existing file or a filetype normally\n\t * handled by html-validate but the path will be used when resolving\n\t * configuration. As a rule-of-thumb, set it to the elements json file.\n\t */\n\tpublic getElementsSchemaSync(filename?: string): SchemaObject {\n\t\tconst config = this.getConfigForSync(filename ?? \"inline\");\n\t\tconst metaTable = config.getMetaTable();\n\t\treturn metaTable.getJSONSchema();\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule. Configuration will be\n\t * resolved for given filename.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = await htmlvalidate.validateFile(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = await htmlvalidate.getContextualDocumentation(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param filename - Filename used to resolve configuration.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentation(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilename?: string,\n\t): Promise<RuleDocumentation | null>;\n\n\t/**\n\t * Get contextual documentation for the given rule using provided\n\t * configuration.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = await htmlvalidate.validateFile(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = await htmlvalidate.getRuleDocumentation(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param config - Configuration to use.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentation(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tconfig: ResolvedConfig | Promise<ResolvedConfig>,\n\t): Promise<RuleDocumentation | null>;\n\n\tpublic async getContextualDocumentation(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilenameOrConfig: ResolvedConfig | Promise<ResolvedConfig> | string = \"inline\",\n\t): Promise<RuleDocumentation | null> {\n\t\tconst config =\n\t\t\ttypeof filenameOrConfig === \"string\"\n\t\t\t\t? await this.getConfigFor(filenameOrConfig)\n\t\t\t\t: await filenameOrConfig;\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.getRuleDocumentation(message);\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule. Configuration will be\n\t * resolved for given filename.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = htmlvalidate.validateFileSync(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = htmlvalidate.getRuleDocumentationSync(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param filename - Filename used to resolve configuration.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentationSync(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilename?: string,\n\t): RuleDocumentation | null;\n\n\t/**\n\t * Get contextual documentation for the given rule using provided\n\t * configuration.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = htmlvalidate.validateFileSync(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = htmlvalidate.getRuleDocumentationSync(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param config - Configuration to use.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentationSync(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tconfig: ResolvedConfig,\n\t): RuleDocumentation | null;\n\n\tpublic getContextualDocumentationSync(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilenameOrConfig: ResolvedConfig | string = \"inline\",\n\t): RuleDocumentation | null {\n\t\tconst config =\n\t\t\ttypeof filenameOrConfig === \"string\"\n\t\t\t\t? this.getConfigForSync(filenameOrConfig)\n\t\t\t\t: filenameOrConfig;\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.getRuleDocumentation(message);\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule.\n\t *\n\t * Typical usage:\n\t *\n\t * ```js\n\t * const report = await htmlvalidate.validateFile(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   const config = await htmlvalidate.getConfigFor(result.filePath);\n\t *   for (const message of result.messages){\n\t *     const documentation = await htmlvalidate.getRuleDocumentation(message.ruleId, config, message.context);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentation]] instead.\n\t * @param ruleId - Rule to get documentation for.\n\t * @param config - If set it provides more accurate description by using the\n\t * correct configuration for the file.\n\t * @param context - If set to `Message.context` some rules can provide\n\t * contextual details and suggestions.\n\t */\n\tpublic async getRuleDocumentation(\n\t\truleId: string,\n\t\tconfig: ResolvedConfig | Promise<ResolvedConfig> | null = null,\n\t\tcontext: unknown | null = null,\n\t): Promise<RuleDocumentation | null> {\n\t\tconst c = config ?? this.getConfigFor(\"inline\");\n\t\tconst engine = new Engine(await c, Parser);\n\t\treturn engine.getRuleDocumentation({ ruleId, context });\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule.\n\t *\n\t * Typical usage:\n\t *\n\t * ```js\n\t * const report = htmlvalidate.validateFileSync(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   const config = htmlvalidate.getConfigForSync(result.filePath);\n\t *   for (const message of result.messages){\n\t *     const documentation = htmlvalidate.getRuleDocumentationSync(message.ruleId, config, message.context);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentationSync]] instead.\n\t * @param ruleId - Rule to get documentation for.\n\t * @param config - If set it provides more accurate description by using the\n\t * correct configuration for the file.\n\t * @param context - If set to `Message.context` some rules can provide\n\t * contextual details and suggestions.\n\t */\n\tpublic getRuleDocumentationSync(\n\t\truleId: string,\n\t\tconfig: ResolvedConfig | null = null,\n\t\tcontext: unknown | null = null,\n\t): RuleDocumentation | null {\n\t\tconst c = config ?? this.getConfigForSync(\"inline\");\n\t\tconst engine = new Engine(c, Parser);\n\t\treturn engine.getRuleDocumentation({ ruleId, context });\n\t}\n\n\t/**\n\t * Create a parser configured for given filename.\n\t *\n\t * @internal\n\t * @param source - Source to use.\n\t */\n\tpublic async getParserFor(source: Source): Promise<Parser> {\n\t\tconst config = await this.getConfigFor(source.filename);\n\t\treturn new Parser(config);\n\t}\n\n\t/**\n\t * Get configuration for given filename.\n\t *\n\t * See [[FileSystemConfigLoader]] for details.\n\t *\n\t * @public\n\t * @param filename - Filename to get configuration for.\n\t * @param configOverride - Configuration to apply last.\n\t */\n\tpublic getConfigFor(filename: string, configOverride?: ConfigData): Promise<ResolvedConfig> {\n\t\tconst config = this.configLoader.getConfigFor(filename, configOverride);\n\t\treturn Promise.resolve(config);\n\t}\n\n\t/**\n\t * Get configuration for given filename.\n\t *\n\t * See [[FileSystemConfigLoader]] for details.\n\t *\n\t * @public\n\t * @param filename - Filename to get configuration for.\n\t * @param configOverride - Configuration to apply last.\n\t */\n\tpublic getConfigForSync(filename: string, configOverride?: ConfigData): ResolvedConfig {\n\t\tconst config = this.configLoader.getConfigFor(filename, configOverride);\n\t\tif (isThenable(config)) {\n\t\t\tthrow new UserError(\"Cannot use asynchronous config loader with synchronous api\");\n\t\t}\n\t\treturn config;\n\t}\n\n\t/**\n\t * Get current configuration loader.\n\t *\n\t * @public\n\t * @since %version%\n\t * @returns Current configuration loader.\n\t */\n\t/* istanbul ignore next -- not testing setters/getters */\n\tpublic getConfigLoader(): ConfigLoader {\n\t\treturn this.configLoader;\n\t}\n\n\t/**\n\t * Set configuration loader.\n\t *\n\t * @public\n\t * @since %version%\n\t * @param loader - New configuration loader to use.\n\t */\n\t/* istanbul ignore next -- not testing setters/getters */\n\tpublic setConfigLoader(loader: ConfigLoader): void {\n\t\tthis.configLoader = loader;\n\t}\n\n\t/**\n\t * Flush configuration cache. Clears full cache unless a filename is given.\n\t *\n\t * See [[FileSystemConfigLoader]] for details.\n\t *\n\t * @public\n\t * @param filename - If set, only flush cache for given filename.\n\t */\n\tpublic flushConfigCache(filename?: string): void {\n\t\tthis.configLoader.flushCache(filename);\n\t}\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\n\nlet cachedRootDir: string | null = null;\n\ninterface FSLike {\n\texistsSync(path: string): boolean;\n}\n\n/**\n * @internal\n */\nexport function determineRootDirImpl(intial: string, fs: FSLike): string {\n\t/* try to locate package.json */\n\tlet current = intial;\n\n\twhile (true) {\n\t\tconst search = path.join(current, \"package.json\");\n\t\tif (fs.existsSync(search)) {\n\t\t\treturn current;\n\t\t}\n\n\t\t/* get the parent directory */\n\t\tconst child = current;\n\t\tcurrent = path.dirname(current);\n\n\t\t/* stop if this is the root directory */\n\t\tif (current === child) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* default to working directory if no package.json is found */\n\treturn intial;\n}\n\n/**\n * Try to determine root directory based on the location of the closest\n * `package.json`. Fallbacks on `process.cwd()` if no package.json was found.\n *\n * @internal\n */\n/* istanbul ignore next: cached version of determineRootDirImpl, no need to test */\nexport function determineRootDir(): string {\n\tif (cachedRootDir === null) {\n\t\tcachedRootDir = determineRootDirImpl(process.cwd(), fs);\n\t}\n\treturn cachedRootDir;\n}\n","import path from \"node:path\";\n\n/**\n * @internal\n */\nexport function expandRelativePath<T>(value: string | T, { cwd }: { cwd: string }): string | T {\n\tif (typeof value === \"string\" && value.startsWith(\".\")) {\n\t\treturn path.normalize(path.join(cwd, value));\n\t} else {\n\t\treturn value;\n\t}\n}\n","import path from \"node:path\";\nimport { type MetaDataTable } from \"../../../meta\";\nimport { type Plugin } from \"../../../plugin\";\nimport { legacyRequire } from \"../../../resolve\";\nimport { type Transformer } from \"../../../transform\";\nimport { requireUncached } from \"../../../utils\";\nimport { type ConfigData } from \"../../config-data\";\nimport { ConfigError } from \"../../error\";\nimport { type Resolver, type ResolverOptions } from \"../resolver\";\nimport { determineRootDir } from \"./determine-root-dir\";\nimport { expandRelativePath } from \"./expand-relative-path\";\n\n/**\n * @internal\n */\nexport interface RequireError extends Error {\n\tcode: string;\n}\n\nfunction isRequireError(error: unknown): error is RequireError {\n\treturn Boolean(error && typeof error === \"object\" && \"code\" in error);\n}\n\nfunction isTransformer(value: Transformer | Plugin): value is Transformer {\n\treturn typeof value === \"function\";\n}\n\n/**\n * CommonJS resolver.\n *\n * @public\n * @since 8.8.0\n */\nexport type CommonJSResolver = Required<Resolver>;\n\n/**\n * CommonJS resolver.\n *\n * @public\n * @deprecated Deprecated alias for [[CommonJSResolver]].\n * @since 8.0.0\n */\nexport type NodeJSResolver = Required<Resolver>;\n\n/**\n * Create a new resolver for NodeJS packages using `require(..)`.\n *\n * If the module name contains `<rootDir>` (e.g. `<rootDir/foo`) it will be\n * expanded relative to the root directory either explicitly set by the\n * `rootDir` parameter or determined automatically by the closest `package.json`\n * file (starting at the current working directory).\n *\n * @public\n * @since 8.8.0\n */\nexport function cjsResolver(options: { rootDir?: string } = {}): CommonJSResolver {\n\tconst rootDir = options.rootDir ?? determineRootDir();\n\n\t/* eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters -- technical debt, should return unknown as use explicit cast */\n\tfunction internalRequire<T = unknown>(id: string, { cache }: ResolverOptions): T | null {\n\t\tconst moduleName = id.replace(\"<rootDir>\", rootDir);\n\t\ttry {\n\t\t\t/* istanbul ignore else: the tests only runs the cached versions to get\n\t\t\t * unmodified access to `require`, the implementation of `requireUncached`\n\t\t\t * is assumed to be tested elsewhere */\n\t\t\tif (cache) {\n\t\t\t\treturn legacyRequire(moduleName) as T;\n\t\t\t} else {\n\t\t\t\treturn requireUncached(legacyRequire, moduleName) as T;\n\t\t\t}\n\t\t} catch (err: unknown) {\n\t\t\tif (isRequireError(err) && err.code === \"MODULE_NOT_FOUND\") {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn {\n\t\tname: \"nodejs-resolver\",\n\n\t\tresolveElements(id: string, options: ResolverOptions): MetaDataTable | null {\n\t\t\treturn internalRequire(id, options);\n\t\t},\n\n\t\tresolveConfig(id: string, options: ResolverOptions): ConfigData | null {\n\t\t\tconst configData = internalRequire<ConfigData>(id, options);\n\t\t\tif (!configData) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t/* expand any relative paths */\n\t\t\tconst cwd = path.dirname(id);\n\t\t\tconst expand = <T>(value: string | T): string | T => expandRelativePath(value, { cwd });\n\n\t\t\tif (Array.isArray(configData.elements)) {\n\t\t\t\tconfigData.elements = configData.elements.map(expand);\n\t\t\t}\n\n\t\t\tif (Array.isArray(configData.extends)) {\n\t\t\t\tconfigData.extends = configData.extends.map(expand);\n\t\t\t}\n\n\t\t\tif (Array.isArray(configData.plugins)) {\n\t\t\t\tconfigData.plugins = configData.plugins.map(expand);\n\t\t\t}\n\n\t\t\treturn configData;\n\t\t},\n\n\t\tresolvePlugin(id: string, options: ResolverOptions): Plugin | null {\n\t\t\treturn internalRequire<Plugin>(id, options);\n\t\t},\n\n\t\tresolveTransformer(id: string, options: ResolverOptions): Transformer | null {\n\t\t\tconst mod = internalRequire<Transformer | Plugin>(id, options);\n\t\t\tif (!mod) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (isTransformer(mod)) {\n\t\t\t\treturn mod;\n\t\t\t}\n\n\t\t\t/* this is not a proper transformer, is it a plugin exposing a transformer? */\n\t\t\tif (mod.transformer) {\n\t\t\t\tthrow new ConfigError(\n\t\t\t\t\t`Module \"${id}\" is not a valid transformer. This looks like a plugin, did you forget to load the plugin first?`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthrow new ConfigError(`Module \"${id}\" is not a valid transformer.`);\n\t\t},\n\t};\n}\n\n/**\n * Create a new resolver for NodeJS packages using `require(..)`.\n *\n * If the module name contains `<rootDir>` (e.g. `<rootDir/foo`) it will be\n * expanded relative to the root directory either explicitly set by the\n * `rootDir` parameter or determined automatically by the closest `package.json`\n * file (starting at the current working directory).\n *\n * @public\n * @deprecated Deprecated alias for [[commonjsResolver]].\n * @since 8.0.0\n */\n/* istanbul ignore next -- deprecated alias */\n/* eslint-disable-next-line @typescript-eslint/no-deprecated -- deprecated but should still work */\nexport function nodejsResolver(options: { rootDir?: string } = {}): NodeJSResolver {\n\treturn cjsResolver(options);\n}\n","/* istanbul ignore file: this file is only for easier mocking */\n\n/**\n * Wrapper around import() so we can mock it in unittests.\n *\n * @internal\n */\nexport function importFunction(id: string): unknown {\n\treturn import(id);\n}\n","import { existsSync } from \"node:fs\";\nimport fs from \"node:fs/promises\";\nimport { pathToFileURL } from \"node:url\";\nimport { importResolve } from \"../../../resolve\";\nimport { UserError } from \"../../../error\";\nimport { type ResolverOptions } from \"../resolver\";\nimport { importFunction } from \"./import-function\";\n\n/**\n * @internal\n */\nexport interface ImportError extends Error {\n\tcode: string;\n\trequireStack?: string[];\n}\n\nasync function getModuleName(\n\tid: string,\n\t{ cache, rootDir }: { cache: boolean; rootDir: string },\n): Promise<URL> {\n\tconst moduleName = id.replace(\"<rootDir>\", rootDir);\n\tconst url = existsSync(id) ? pathToFileURL(id) : importResolve(moduleName);\n\n\tif (url.protocol !== \"file:\") {\n\t\treturn url;\n\t}\n\n\t/* istanbul ignore else: the tests only runs the cached versions */\n\tif (cache) {\n\t\treturn url;\n\t} else {\n\t\t/* Cachebusting in ESM is tricky, we cannot flush the cache of the old import\n\t\t * but a common workaround is to append ?something to the path. It only works\n\t\t * with absolute paths though so we must first use `import.meta.resolve(..)`\n\t\t * which doesn't play nice with CJS. Then we will leak memory each time a\n\t\t * fresh copy is loaded and there doesn't seem to be a way to deal with this\n\t\t * yet. We use the file mtime to at least try to retain the copy as long as\n\t\t * possible but this will fail for transitive imports but at least with\n\t\t * directly loaded configurations it would reload property. */\n\t\tconst stat = await fs.stat(url);\n\t\turl.searchParams.append(\"mtime\", String(stat.mtime.getTime()));\n\t\treturn url;\n\t}\n}\n\nfunction isImportError(error: unknown): error is ImportError {\n\treturn Boolean(error && typeof error === \"object\" && \"code\" in error);\n}\n\n/**\n * @internal\n */\nexport async function internalImport<T = unknown>(\n\tid: string,\n\trootDir: string,\n\t{ cache }: ResolverOptions,\n): Promise<T | null> {\n\t/* this is a workaround for rollup which mangles import attributes so we\n\t * cannot use `import(.., { with: { type: \"json\" } })` to import a json\n\t * file. */\n\t/* istanbul ignore if: workaround, not tested, should be removed if the compiler bug is fixed */\n\tif (id.endsWith(\".json\")) {\n\t\tconst content = await fs.readFile(id, \"utf-8\");\n\t\treturn JSON.parse(content) as T;\n\t}\n\n\ttry {\n\t\tconst url = await getModuleName(id, { cache, rootDir });\n\t\tif (url.protocol !== \"file:\") {\n\t\t\treturn null;\n\t\t}\n\t\tconst moduleName = url.toString();\n\t\tconst { default: defaultImport } = (await importFunction(moduleName)) as { default: T };\n\t\tif (!defaultImport) {\n\t\t\tthrow new UserError(`\"${id}\" does not have a default export`);\n\t\t}\n\t\treturn defaultImport;\n\t} catch (err: unknown) {\n\t\tif (isImportError(err) && err.code === \"MODULE_NOT_FOUND\" && !err.requireStack) {\n\t\t\treturn null;\n\t\t}\n\t\tthrow err;\n\t}\n}\n","import path from \"node:path\";\nimport { type MetaDataTable } from \"../../../meta\";\nimport { type Plugin } from \"../../../plugin\";\nimport { type Transformer } from \"../../../transform\";\nimport { type ConfigData } from \"../../config-data\";\nimport { ConfigError } from \"../../error\";\nimport { type Resolver, type ResolverOptions } from \"../resolver\";\nimport { determineRootDir } from \"./determine-root-dir\";\nimport { expandRelativePath } from \"./expand-relative-path\";\nimport { internalImport } from \"./internal-import\";\n\nfunction isTransformer(value: Transformer | Plugin): value is Transformer {\n\treturn typeof value === \"function\";\n}\n\n/**\n * ESM resolver.\n *\n * @public\n * @since 9.0.0\n */\nexport type ESMResolver = Required<Resolver>;\n\n/**\n * Create a new resolver for NodeJS packages using `import(..)`.\n *\n * If the module name contains `<rootDir>` (e.g. `<rootDir/foo`) it will be\n * expanded relative to the root directory either explicitly set by the\n * `rootDir` parameter or determined automatically by the closest `package.json`\n * file (starting at the current working directory).\n *\n * @public\n * @since 9.0.0\n */\nexport function esmResolver(options: { rootDir?: string } = {}): ESMResolver {\n\tconst rootDir = options.rootDir ?? determineRootDir();\n\n\treturn {\n\t\tname: \"esm-resolver\",\n\n\t\tresolveElements(id: string, options: ResolverOptions): Promise<MetaDataTable | null> {\n\t\t\treturn internalImport(id, rootDir, options);\n\t\t},\n\n\t\tasync resolveConfig(id: string, options: ResolverOptions): Promise<ConfigData | null> {\n\t\t\tconst configData = await internalImport<ConfigData>(id, rootDir, options);\n\t\t\tif (!configData) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t/* expand any relative paths */\n\t\t\tconst cwd = path.dirname(id);\n\t\t\tconst expand = <T>(value: string | T): string | T => expandRelativePath(value, { cwd });\n\n\t\t\tif (Array.isArray(configData.elements)) {\n\t\t\t\tconfigData.elements = configData.elements.map(expand);\n\t\t\t}\n\n\t\t\tif (Array.isArray(configData.extends)) {\n\t\t\t\tconfigData.extends = configData.extends.map(expand);\n\t\t\t}\n\n\t\t\tif (Array.isArray(configData.plugins)) {\n\t\t\t\tconfigData.plugins = configData.plugins.map(expand);\n\t\t\t}\n\n\t\t\treturn configData;\n\t\t},\n\n\t\tresolvePlugin(id: string, options: ResolverOptions): Promise<Plugin | null> {\n\t\t\treturn internalImport<Plugin>(id, rootDir, options);\n\t\t},\n\n\t\tasync resolveTransformer(id: string, options: ResolverOptions): Promise<Transformer | null> {\n\t\t\tconst mod = await internalImport<Transformer | Plugin>(id, rootDir, options);\n\t\t\tif (!mod) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (isTransformer(mod)) {\n\t\t\t\treturn mod;\n\t\t\t}\n\n\t\t\t/* this is not a proper transformer, is it a plugin exposing a transformer? */\n\t\t\tif (mod.transformer) {\n\t\t\t\tthrow new ConfigError(\n\t\t\t\t\t`Module \"${id}\" is not a valid transformer. This looks like a plugin, did you forget to load the plugin first?`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthrow new ConfigError(`Module \"${id}\" is not a valid transformer.`);\n\t\t},\n\t};\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport { Config } from \"../config\";\nimport { type ConfigData } from \"../config-data\";\nimport { ConfigLoader } from \"../config-loader\";\nimport { type ResolvedConfig } from \"../resolved-config\";\nimport { type Resolver } from \"../resolver\";\nimport { type FSLike, esmResolver } from \"../resolver/nodejs\";\nimport { isThenable } from \"../../utils\";\n\n/**\n * Options for [[FileSystemConfigLoader]].\n *\n * @public\n */\nexport interface FileSystemConfigLoaderOptions {\n\t/** An implementation of `fs` as needed by [[FileSystemConfigLoader]] */\n\tfs: FSLike;\n}\n\n/**\n * @internal\n */\nfunction findConfigurationFiles(fs: FSLike, directory: string): string[] {\n\treturn [\"json\", \"mjs\", \"cjs\", \"js\"]\n\t\t.map((extension) => path.join(directory, `.htmlvalidate.${extension}`))\n\t\t.filter((filePath) => fs.existsSync(filePath));\n}\n\nconst defaultResolvers: Resolver[] = [esmResolver()];\n\ntype ConstructorParametersDefault = [ConfigData?, Partial<FileSystemConfigLoaderOptions>?];\ntype ConstructorParametersResolver = [\n\tResolver[],\n\tConfigData?,\n\tPartial<FileSystemConfigLoaderOptions>?,\n];\ntype ConstructorParameters = ConstructorParametersDefault | ConstructorParametersResolver;\n\nfunction hasResolver(value: ConstructorParameters): value is ConstructorParametersResolver {\n\treturn Array.isArray(value[0]);\n}\n\n/**\n * Loads configuration by traversing filesystem.\n *\n * Configuration is read from three sources and in the following order:\n *\n * 1. Global configuration passed to constructor.\n * 2. Configuration files found when traversing the directory structure.\n * 3. Override passed to this function.\n *\n * The following configuration filenames are searched:\n *\n * - `.htmlvalidate.json`\n * - `.htmlvalidate.js`\n * - `.htmlvalidate.cjs`\n * - `.htmlvalidate.mjs`\n *\n * Global configuration is used when no configuration file is found. The\n * result is always merged with override if present.\n *\n * The `root` property set to `true` affects the configuration as following:\n *\n * 1. If set in override the override is returned as-is.\n * 2. If set in the global config the override is merged into global and\n * returned. No configuration files are searched.\n * 3. Setting `root` in configuration file only stops directory traversal.\n *\n * @public\n */\nexport class FileSystemConfigLoader extends ConfigLoader {\n\tprotected cache: Map<string, Config | null>;\n\tprivate fs: FSLike;\n\n\t/**\n\t * Create a filesystem configuration loader with default resolvers.\n\t *\n\t * @param fs - `fs` implementation,\n\t * @param config - Global configuration.\n\t * @param configFactory - Optional configuration factory.\n\t */\n\tpublic constructor(config?: ConfigData, options?: Partial<FileSystemConfigLoaderOptions>);\n\n\t/**\n\t * Create a filesystem configuration loader with custom resolvers.\n\t *\n\t * @param fs - `fs` implementation,\n\t * @param resolvers - Resolvers to use.\n\t * @param config - Global configuration.\n\t * @param configFactory - Optional configuration factory.\n\t */\n\tpublic constructor(\n\t\tresolvers: Resolver[],\n\t\tconfig?: ConfigData,\n\t\toptions?: Partial<FileSystemConfigLoaderOptions>,\n\t);\n\n\tpublic constructor(...args: ConstructorParameters) {\n\t\tif (hasResolver(args)) {\n\t\t\t/* istanbul ignore next */\n\t\t\tconst [resolvers, config, options = {}] = args;\n\t\t\tsuper(resolvers, config);\n\t\t\tthis.fs = /* istanbul ignore next */ options.fs ?? fs;\n\t\t} else {\n\t\t\t/* istanbul ignore next */\n\t\t\tconst [config, options = {}] = args;\n\t\t\tsuper(defaultResolvers, config);\n\t\t\tthis.fs = /* istanbul ignore next */ options.fs ?? fs;\n\t\t}\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * Get configuration for given filename.\n\t *\n\t * @param filename - Filename to get configuration for.\n\t * @param configOverride - Configuration to merge final result with.\n\t */\n\tpublic override getConfigFor(\n\t\tfilename: string,\n\t\tconfigOverride?: ConfigData,\n\t): ResolvedConfig | Promise<ResolvedConfig> {\n\t\tconst override = this.loadFromObject(configOverride ?? {});\n\t\tif (isThenable(override)) {\n\t\t\treturn override.then((override) => {\n\t\t\t\treturn this._resolveAsync(filename, override);\n\t\t\t});\n\t\t} else {\n\t\t\treturn this._resolveSync1(filename, override);\n\t\t}\n\t}\n\n\t/**\n\t * Flush configuration cache.\n\t *\n\t * @param filename - If given only the cache for that file is flushed.\n\t */\n\tpublic override flushCache(filename?: string): void {\n\t\tif (filename) {\n\t\t\tthis.cache.delete(filename);\n\t\t} else {\n\t\t\tthis.cache.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Load raw configuration from directory traversal.\n\t *\n\t * This configuration is not merged with global configuration and may return\n\t * `null` if no configuration files are found.\n\t */\n\n\tpublic fromFilename(filename: string): Config | Promise<Config | null> | null {\n\t\tif (filename === \"inline\") {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst cache = this.cache.get(filename);\n\t\tif (cache) {\n\t\t\treturn cache;\n\t\t}\n\n\t\tlet found = false;\n\t\tlet current = path.resolve(path.dirname(filename));\n\t\tlet config = this.empty();\n\n\t\twhile (true) {\n\t\t\t/* search configuration files in current directory */\n\t\t\tfor (const configFile of findConfigurationFiles(this.fs, current)) {\n\t\t\t\tconst local = this.loadFromFile(configFile);\n\n\t\t\t\t/* if the loader returns an async config we exit out of the synchronous\n\t\t\t\t * processing and enter the async method so we can resolve any promises\n\t\t\t\t * as we go */\n\t\t\t\tif (isThenable(local)) {\n\t\t\t\t\treturn this.fromFilenameAsync(filename);\n\t\t\t\t}\n\n\t\t\t\tfound = true;\n\n\t\t\t\tconst merged = local.merge(this.resolvers, config);\n\n\t\t\t\t/* istanbul ignore if -- should never happen */\n\t\t\t\tif (isThenable(merged)) {\n\t\t\t\t\tthrow new Error(\"internal error: async result ended up in sync path\");\n\t\t\t\t}\n\t\t\t\tconfig = merged;\n\t\t\t}\n\n\t\t\t/* stop if a configuration with \"root\" is set to true */\n\t\t\tif (config.isRootFound()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* get the parent directory */\n\t\t\tconst child = current;\n\t\t\tcurrent = path.dirname(current);\n\n\t\t\t/* stop if this is the root directory */\n\t\t\tif (current === child) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* no config was found by loader, return null and let caller decide what to do */\n\t\tif (!found) {\n\t\t\tthis.cache.set(filename, null);\n\t\t\treturn null;\n\t\t}\n\n\t\tthis.cache.set(filename, config);\n\t\treturn config;\n\t}\n\n\t/**\n\t * Async version of [[fromFilename]].\n\t *\n\t * @internal\n\t */\n\tpublic async fromFilenameAsync(filename: string): Promise<Config | null> {\n\t\tif (filename === \"inline\") {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst cache = this.cache.get(filename);\n\t\tif (cache) {\n\t\t\treturn cache;\n\t\t}\n\n\t\tlet found = false;\n\t\tlet current = path.resolve(path.dirname(filename));\n\t\tlet config = this.empty();\n\n\t\twhile (true) {\n\t\t\t/* search configuration files in current directory */\n\t\t\tfor (const configFile of findConfigurationFiles(this.fs, current)) {\n\t\t\t\tconst local = await this.loadFromFile(configFile);\n\t\t\t\tfound = true;\n\t\t\t\tconfig = await local.merge(this.resolvers, config);\n\t\t\t}\n\n\t\t\t/* stop if a configuration with \"root\" is set to true */\n\t\t\tif (config.isRootFound()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* get the parent directory */\n\t\t\tconst child = current;\n\t\t\tcurrent = path.dirname(current);\n\n\t\t\t/* stop if this is the root directory */\n\t\t\tif (current === child) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* no config was found by loader, return null and let caller decide what to do */\n\t\tif (!found) {\n\t\t\tthis.cache.set(filename, null);\n\t\t\treturn null;\n\t\t}\n\n\t\tthis.cache.set(filename, config);\n\t\treturn config;\n\t}\n\n\tprivate _merge(\n\t\tglobalConfig: Config,\n\t\toverride: Config,\n\t\tconfig: Config | null,\n\t): ResolvedConfig | Promise<ResolvedConfig> {\n\t\tconst merged = config\n\t\t\t? config.merge(this.resolvers, override)\n\t\t\t: globalConfig.merge(this.resolvers, override);\n\t\t/* istanbul ignore if -- covered by tsc, hard to recreate even with very specific testcases */\n\t\tif (isThenable(merged)) {\n\t\t\treturn merged.then((merged) => {\n\t\t\t\treturn merged.resolve();\n\t\t\t});\n\t\t} else {\n\t\t\treturn merged.resolve();\n\t\t}\n\t}\n\n\tprivate _resolveSync1(\n\t\tfilename: string,\n\t\toverride: Config,\n\t): ResolvedConfig | Promise<ResolvedConfig> {\n\t\tif (override.isRootFound()) {\n\t\t\treturn override.resolve();\n\t\t}\n\n\t\tconst globalConfig = this.getGlobalConfig();\n\t\t/* istanbul ignore if -- covered by tsc, hard to recreate even with very specific testcases */\n\t\tif (isThenable(globalConfig)) {\n\t\t\treturn globalConfig.then((globalConfig) => {\n\t\t\t\treturn this._resolveSync2(filename, override, globalConfig);\n\t\t\t});\n\t\t} else {\n\t\t\treturn this._resolveSync2(filename, override, globalConfig);\n\t\t}\n\t}\n\n\tprivate _resolveSync2(\n\t\tfilename: string,\n\t\toverride: Config,\n\t\tglobalConfig: Config,\n\t): ResolvedConfig | Promise<ResolvedConfig> {\n\t\t/* special case when the global configuration is marked as root, should not\n\t\t * try to load and more configuration files */\n\t\tif (globalConfig.isRootFound()) {\n\t\t\tconst merged = globalConfig.merge(this.resolvers, override);\n\t\t\t/* istanbul ignore if -- covered by tsc, hard to recreate even with very specific testcases */\n\t\t\tif (isThenable(merged)) {\n\t\t\t\treturn merged.then((merged) => {\n\t\t\t\t\treturn merged.resolve();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn merged.resolve();\n\t\t\t}\n\t\t}\n\n\t\tconst config = this.fromFilename(filename);\n\t\tif (isThenable(config)) {\n\t\t\treturn config.then((config) => {\n\t\t\t\treturn this._merge(globalConfig, override, config);\n\t\t\t});\n\t\t} else {\n\t\t\treturn this._merge(globalConfig, override, config);\n\t\t}\n\t}\n\n\tprivate async _resolveAsync(filename: string, override: Config): Promise<ResolvedConfig> {\n\t\tif (override.isRootFound()) {\n\t\t\treturn override.resolve();\n\t\t}\n\n\t\tconst globalConfig = await this.getGlobalConfig();\n\n\t\t/* special case when the global configuration is marked as root, should not\n\t\t * try to load and more configuration files */\n\t\tif (globalConfig.isRootFound()) {\n\t\t\tconst merged = await globalConfig.merge(this.resolvers, override);\n\t\t\treturn merged.resolve();\n\t\t}\n\n\t\tconst config = await this.fromFilenameAsync(filename);\n\t\treturn this._merge(globalConfig, override, config);\n\t}\n\n\t/**\n\t * @internal For testing only\n\t */\n\tpublic _getInternalCache(): Map<string, Config | null> {\n\t\treturn this.cache;\n\t}\n\n\tprotected defaultConfig(): Config | Promise<Config> {\n\t\treturn Config.defaultConfig();\n\t}\n}\n","import kleur from \"kleur\";\nimport { version } from \"../generated/package\";\nimport { type CompatibilityOptions, compatibilityCheckImpl } from \"./compatibility-check\";\n\nconst defaults: CompatibilityOptions = {\n\tsilent: false,\n\tversion,\n\tlogger(text: string): void {\n\t\t/* eslint-disable-next-line no-console -- expected to log */\n\t\tconsole.error(kleur.red(text));\n\t},\n};\n\n/**\n * Tests if plugin is compatible with html-validate library. Unless the `silent`\n * option is used a warning is displayed on the console.\n *\n * @public\n * @since v5.0.0\n * @param name - Name of plugin\n * @param declared - What library versions the plugin support (e.g. declared peerDependencies)\n * @returns - `true` if version is compatible\n */\nexport function compatibilityCheck(\n\tname: string,\n\tdeclared: string,\n\toptions?: Partial<CompatibilityOptions>,\n): boolean {\n\treturn compatibilityCheckImpl(name, declared, {\n\t\t...defaults,\n\t\t...options,\n\t});\n}\n"],"names":["fs","isTransformer","options","override","merged","globalConfig","config"],"mappings":"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"}